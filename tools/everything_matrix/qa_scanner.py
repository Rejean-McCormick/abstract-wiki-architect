import os
import xml.etree.ElementTree as ET
from pathlib import Path
from typing import Dict, Optional

try:
    import pgf
except ImportError:
    pgf = None

# --- GLOBAL CACHE ---
# This singleton prevents reloading the ~50MB binary 50+ times (saving ~100s).
_CACHED_GRAMMAR = None

def load_grammar_once(pgf_path: Path):
    """
    Singleton loader for the PGF binary. 
    Loads it once into memory and returns the reference for subsequent calls.
    """
    global _CACHED_GRAMMAR
    
    if _CACHED_GRAMMAR:
        return _CACHED_GRAMMAR
    
    if not pgf:
        return None

    if pgf_path.exists():
        try:
            # print(f"üì¶ Loading PGF binary into memory (One-time cost)...") 
            # Commented out print to keep logs clean during scan
            _CACHED_GRAMMAR = pgf.readPGF(str(pgf_path))
            return _CACHED_GRAMMAR
        except Exception as e:
            print(f"‚ö†Ô∏è  [QA Scanner] PGF Load Error: {e}")
            return None
    return None

def scan_artifacts(lang: str, gf_dir: Path) -> Dict[str, float]:
    """
    Scans Zone D (Quality) artifacts.
    Returns:
      BIN: 1.0 if language is present in AbstractWiki.pgf, else 0.0.
      TEST: 0.0 - 1.0 representing the pass rate in the latest regression test.
    """
    stats = {
        "BIN": 0.0,
        "TEST": 0.0
    }

    # 1. Scan Binary (BIN)
    # We check if the language code exists inside the compiled PGF.
    pgf_path = gf_dir / "AbstractWiki.pgf"
    
    # USE THE CACHED LOADER
    grammar = load_grammar_once(pgf_path)
    
    if grammar:
        try:
            # Check for standard naming "WikiFra"
            target_lang = f"Wiki{lang.capitalize()}"
            
            # Check for factory naming "WikiFRA" (if applicable)
            target_lang_upper = f"Wiki{lang.upper()}"
            
            if target_lang in grammar.languages:
                stats["BIN"] = 1.0
            elif target_lang_upper in grammar.languages:
                 stats["BIN"] = 1.0
            else:
                # Fallback: scan keys for suffix match (slower but robust for weird names)
                # Only run if direct lookup fails
                for key in grammar.languages.keys():
                    if key.endswith(lang.capitalize()) or key.endswith(lang.upper()):
                        stats["BIN"] = 1.0
                        break
                        
        except Exception as e:
            # If logic fails, BIN stays 0.0
            pass

    # 2. Scan Test Results (TEST)
    # We look for a JUnit XML report generated by pytest
    # Expected path: data/tests/reports/junit.xml
    # (Configured in pytest.ini: --junitxml=data/tests/reports/junit.xml)
    report_path = gf_dir.parent / "data" / "tests" / "reports" / "junit.xml"
    
    if report_path.exists():
        stats["TEST"] = _parse_junit_report(lang, report_path)
    else:
        # If no report exists, BIN stays as is, TEST stays 0.0
        pass

    return stats

def _parse_junit_report(lang: str, path: Path) -> float:
    """
    Parses a JUnit XML file to calculate pass rate for a specific language.
    Assumes test case names contain the language code (e.g., 'test_bio_fra').
    """
    try:
        tree = ET.parse(path)
        root = tree.getroot()
        
        total_tests = 0
        passed_tests = 0
        
        # Iterate over all test cases
        for testcase in root.iter("testcase"):
            name = testcase.get("name", "").lower()
            
            # Filter tests relevant to this language
            # Logic: Look for "_fra" suffix or argument in the test name
            # We check both ISO-3 (if passed) and ISO-2 logic just in case
            if f"_{lang}" in name or f"[{lang}]" in name:
                total_tests += 1
                
                # Check for failure/error elements
                failures = testcase.find("failure")
                errors = testcase.find("error")
                
                if failures is None and errors is None:
                    passed_tests += 1
        
        if total_tests == 0:
            return 0.0
            
        return round(passed_tests / total_tests, 2)

    except ET.ParseError:
        print(f"‚ö†Ô∏è  [QA Scanner] Malformed JUnit XML at {path}")
        return 0.0
    except Exception as e:
        print(f"‚ö†Ô∏è  [QA Scanner] Error parsing tests: {e}")
        return 0.0