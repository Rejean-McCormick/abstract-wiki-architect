"""
Local test runner for the Romance shared engine.

It loads the Romance grammar matrix config, iterates over the CSV test
suites generated by qa_tools/test_suite_generator.py, and compares the
engine output to the expected sentences.
"""

from __future__ import annotations

import csv
import json
import os
import sys
from typing import Dict, List

# Add project root to path so we can find 'data' and 'qa_tools'
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(PROJECT_ROOT)

from prototypes.shared_romance_engine import render_romance_bio  # noqa: E402


def load_config() -> Dict[str, object]:
    """Load the Romance grammar matrix configuration JSON."""
    path = os.path.join("data", "romance_grammar_matrix.json")
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def _iter_test_files(test_dir: str) -> List[str]:
    """Return a sorted list of CSV test files under `test_dir`."""
    return sorted(f for f in os.listdir(test_dir) if f.lower().endswith(".csv"))


def _extract_lang_code(filename: str) -> str:
    """
    Extract language code from file name.

    Example:
        "test_suite_it.csv" -> "it"
    """
    base = os.path.basename(filename)
    # Split on '_' and take last part, strip extension
    return base.split("_")[-1].replace(".csv", "")


def run_tests() -> None:
    """Execute all local CSV-based tests against the shared Romance engine."""
    print("ðŸš€ STARTING LOCAL TEST RUNNER...")
    print("--------------------------------")

    config = load_config()
    matrix: Dict[str, Dict[str, object]] = config["languages"]  # type: ignore[assignment]

    # Path to the CSVs generated by the test suite generator
    test_dir = os.path.join("qa_tools", "generated_datasets")

    if not os.path.exists(test_dir):
        print(
            "âŒ Error: Test directory "
            f"'{test_dir}' not found. "
            "Run 'qa_tools/test_suite_generator.py' first."
        )
        return

    files = _iter_test_files(test_dir)

    if not files:
        print("âš ï¸  No CSV files found. Please generate tests first.")
        return

    total_passed = 0
    total_failed = 0
    total_skipped = 0

    for filename in files:
        lang_code = _extract_lang_code(filename)

        if lang_code not in matrix:
            print(
                "âš ï¸  Skipping "
                f"{filename}: language '{lang_code}' not in grammar matrix."
            )
            continue

        lang_cfg: Dict[str, object] = matrix[lang_code]  # type: ignore[assignment]
        lang_name = str(lang_cfg.get("name", lang_code))

        print(f"\nðŸ“‚ Testing language: {lang_name} ({lang_code})")

        filepath = os.path.join(test_dir, filename)

        with open(filepath, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)

            for row in reader:
                # Check if we have an expected output to compare against
                expected = (row.get("EXPECTED_FULL_SENTENCE") or "").strip()

                # Inputs
                name = row["Name"]
                gender = row["Gender (Male/Female)"]

                # Column headers depend on the language display name
                prof_col = f"Profession_Lemma_in_{lang_name}"
                nat_col = f"Nationality_Lemma_in_{lang_name}"

                prof_raw = row.get(prof_col, "")
                nat_raw = row.get(nat_col, "")

                # Handling the placeholder brackets [Actor] -> Actor
                prof = prof_raw.replace("[", "").replace("]", "").strip()
                nat = nat_raw.replace("[", "").replace("]", "").strip()

                # Skip if the CSV hasn't been filled out by AI yet
                if not prof or prof.startswith("Concept"):
                    total_skipped += 1
                    continue

                # --- Engine call ---
                actual = render_romance_bio(
                    name=name,
                    gender=gender,
                    prof_lemma=prof,
                    nat_lemma=nat,
                    config=lang_cfg,
                )

                if expected:
                    if actual == expected:
                        print(f"  âœ… PASS: {actual}")
                        total_passed += 1
                    else:
                        print(f"  âŒ FAIL: {name}")
                        print(f"     Expected: {expected}")
                        print(f"     Got:      {actual}")
                        total_failed += 1
                else:
                    # If no expected output, just print result for manual checking
                    print(f"  ðŸ‘€ PREVIEW: {actual}")
                    total_skipped += 1

    print("\n--------------------------------")
    print(
        "SUMMARY: "
        f"{total_passed} passed | "
        f"{total_failed} failed | "
        f"{total_skipped} pending/skipped"
    )

    if total_failed == 0 and total_passed > 0:
        print(
            "ðŸŽ‰ GREAT SUCCESS! The engine is consistent with the " "Romance test data."
        )


if __name__ == "__main__":
    # Ensure we run from project root context
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_root = os.path.dirname(script_dir)
    os.chdir(project_root)

    run_tests()
