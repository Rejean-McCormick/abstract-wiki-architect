<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="0" failures="6" skipped="6" tests="129" time="55.057" timestamp="2026-01-03T15:27:41.482681-05:00" hostname="Chicago"><testcase classname="tests.adapters.test_api_endpoints.TestGenerationEndpoint" name="test_generate_success" time="0.123" /><testcase classname="tests.adapters.test_api_endpoints.TestGenerationEndpoint" name="test_generate_unauthorized" time="0.054" /><testcase classname="tests.adapters.test_api_endpoints.TestGenerationEndpoint" name="test_generate_validation_error" time="0.049" /><testcase classname="tests.adapters.test_api_endpoints.TestManagementEndpoints" name="test_onboard_language_success" time="0.059" /><testcase classname="tests.adapters.test_api_endpoints.TestManagementEndpoints" name="test_trigger_build_accepted" time="0.051" /><testcase classname="tests.adapters.test_api_endpoints.TestHealthEndpoints" name="test_liveness" time="0.058" /><testcase classname="tests.adapters.test_api_endpoints.TestHealthEndpoints" name="test_readiness_healthy" time="0.050" /><testcase classname="tests.adapters.test_api_endpoints.TestHealthEndpoints" name="test_readiness_unhealthy" time="0.047" /><testcase classname="tests.adapters.test_wikidata_adapter.TestWikidataAdapter" name="test_fetch_lexemes_success" time="0.003" /><testcase classname="tests.adapters.test_wikidata_adapter.TestWikidataAdapter" name="test_fetch_lexemes_network_error" time="0.003" /><testcase classname="tests.adapters.test_wikidata_adapter.TestWikidataAdapter" name="test_circuit_breaker_open" time="0.001" /><testcase classname="tests.core.test_domain_models.TestFrameModel" name="test_valid_frame_creation" time="0.001" /><testcase classname="tests.core.test_domain_models.TestFrameModel" name="test_frame_missing_required_fields" time="0.000" /><testcase classname="tests.core.test_domain_models.TestFrameModel" name="test_frame_immutability_check" time="0.000" /><testcase classname="tests.core.test_domain_models.TestLexiconEntryModel" name="test_valid_entry" time="0.000" /><testcase classname="tests.core.test_domain_models.TestLexiconEntryModel" name="test_entry_default_values" time="0.000" /><testcase classname="tests.core.test_domain_models.TestLanguageModel" name="test_language_status_defaults" time="0.001" /><testcase classname="tests.core.test_use_cases.TestGenerateText" name="test_execute_success" time="0.005" /><testcase classname="tests.core.test_use_cases.TestGenerateText" name="test_execute_invalid_frame" time="0.006" /><testcase classname="tests.core.test_use_cases.TestGenerateText" name="test_execute_engine_failure" time="0.013" /><testcase classname="tests.core.test_use_cases.TestBuildLanguage" name="test_execute_success" time="0.006" /><testcase classname="tests.core.test_use_cases.TestBuildLanguage" name="test_execute_invalid_strategy" time="0.006" /><testcase classname="tests.http_api.test_ai" name="test_ai_suggestions_basic" time="0.055" /><testcase classname="tests.http_api.test_ai" name="test_ai_suggestions_requires_utterance" time="0.042" /><testcase classname="tests.http_api.test_ai" name="test_ai_suggestions_defaults_lang" time="0.038" /><testcase classname="tests.http_api.test_entities" name="test_entities_routes_registered_under_api_prefix" time="0.000" /><testcase classname="tests.http_api.test_entities" name="test_entities_routes_are_tagged_entities" time="0.000" /><testcase classname="tests.http_api.test_frames_registry" name="test_registry_exposes_all_semantic_families" time="0.000" /><testcase classname="tests.http_api.test_frames_registry" name="test_family_members_match_semantic_catalogue_in_order" time="0.000" /><testcase classname="tests.http_api.test_frames_registry" name="test_family_members_are_unique_in_registry" time="0.000" /><testcase classname="tests.http_api.test_generate" name="test_generate_success_minimal_payload" time="0.037" /><testcase classname="tests.http_api.test_generate" name="test_generate_validation_error_missing_frame_type" time="0.035" /><testcase classname="tests.http_api.test_generate" name="test_generate_validation_error_invalid_structure" time="0.040" /><testcase classname="tests.http_api.test_generations" name="test_generate_endpoint_success" time="0.037" /><testcase classname="tests.http_api.test_generations" name="test_generate_validation_error" time="0.036" /><testcase classname="tests.http_api.test_generations" name="test_generate_ninai_protocol_detection" time="0.133" /><testcase classname="tests.integration.test_ninai" name="test_parse_valid_bio_standard" time="0.000" /><testcase classname="tests.integration.test_ninai" name="test_parse_valid_bio_recursive" time="0.000" /><testcase classname="tests.integration.test_ninai" name="test_invalid_root_structure" time="0.001" /><testcase classname="tests.integration.test_ninai" name="test_malformed_bio_args" time="0.000" /><testcase classname="tests.integration.test_ninai" name="test_unsupported_type" time="0.000" /><testcase classname="tests.integration.test_quality" name="test_language_quality_regression[eng-eng_bio_001]" time="0.345"><skipped type="pytest.skip" message="AI Judge unavailable: 400 API key not valid. Please pass a valid API key. [reason: &quot;API_KEY_INVALID&quot;&#10;domain: &quot;googleapis.com&quot;&#10;metadata {&#10;  key: &quot;service&quot;&#10;  value: &quot;generativelanguage.googleapis.com&quot;&#10;}&#10;, locale: &quot;en-US&quot;&#10;message: &quot;API key not valid. Please pass a valid API key.&quot;&#10;]">/mnt/c/MyCode/AbstractWiki/abstract-wiki-architect/tests/integration/test_quality.py:159: AI Judge unavailable: 400 API key not valid. Please pass a valid API key. [reason: "API_KEY_INVALID"
domain: "googleapis.com"
metadata {
  key: "service"
  value: "generativelanguage.googleapis.com"
}
, locale: "en-US"
message: "API key not valid. Please pass a valid API key."
]</skipped></testcase><testcase classname="tests.integration.test_quality" name="test_language_quality_regression[fra-fra_bio_001]" time="0.003"><skipped type="pytest.skip" message="Language fra (WikiFra) not found in PGF binary.">/mnt/c/MyCode/AbstractWiki/abstract-wiki-architect/tests/integration/test_quality.py:124: Language fra (WikiFra) not found in PGF binary.</skipped></testcase><testcase classname="tests.integration.test_quality" name="test_language_quality_regression[fra-fra_bio_002]" time="0.003"><skipped type="pytest.skip" message="Language fra (WikiFra) not found in PGF binary.">/mnt/c/MyCode/AbstractWiki/abstract-wiki-architect/tests/integration/test_quality.py:124: Language fra (WikiFra) not found in PGF binary.</skipped></testcase><testcase classname="tests.integration.test_quality" name="test_language_quality_regression[hau-hau_bio_001]" time="0.002"><skipped type="pytest.skip" message="Language hau (WikiHau) not found in PGF binary.">/mnt/c/MyCode/AbstractWiki/abstract-wiki-architect/tests/integration/test_quality.py:124: Language hau (WikiHau) not found in PGF binary.</skipped></testcase><testcase classname="tests.integration.test_quality" name="test_language_quality_regression[zul-zul_bio_001]" time="0.002"><skipped type="pytest.skip" message="AI Judge unavailable: AI Agent disabled">/mnt/c/MyCode/AbstractWiki/abstract-wiki-architect/tests/integration/test_quality.py:159: AI Judge unavailable: AI Agent disabled</skipped></testcase><testcase classname="tests.integration.test_quality" name="test_judge_connectivity" time="0.001"><skipped type="pytest.skip" message="AI testing skipped: Judge client not initialized (likely invalid/missing key).">/mnt/c/MyCode/AbstractWiki/abstract-wiki-architect/tests/integration/test_quality.py:196: AI testing skipped: Judge client not initialized (likely invalid/missing key).</skipped></testcase><testcase classname="tests.integration.test_worker_flow.TestWorkerFlow" name="test_build_requested_event_triggers_compile_job" time="0.006"><failure message="AssertionError: assert 'Source GF fi...gf/WikiDeu.gf' == 'Compiled deu successfully.'&#10;  &#10;  #x1B[0m#x1B[91m- Compiled deu successfully.#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  #x1B[92m+ Source GF file missing: /repo/gf/WikiDeu.gf#x1B[39;49;00m#x1B[90m#x1B[39;49;00m">self = &lt;test_worker_flow.TestWorkerFlow object at 0x766ab4abf770&gt;

    async def test_build_requested_event_triggers_compile_job(self):
        # Arrange: simulate the domain event payload (producer side)
        event = SystemEvent(
            type=EventType.BUILD_REQUESTED,
            payload={"lang_code": "deu", "strategy": "full"},
        )
        lang_code = event.payload["lang_code"]
    
        base_dir = "/repo"
        pgf_path = f"{base_dir}/gf/AbstractWiki.pgf"
        src_file = f"{base_dir}/gf/WikiGer.gf"  # expected via iso_to_wiki mapping for 'deu' -&gt; 'Ger'
    
        iso_map = {"deu": {"wiki": "Ger"}}
    
        def fake_os_exists(path: str) -&gt; bool:
            p = str(path)
            # [FIX] Robust check: allow if 'build_index.py' is anywhere in the path string
            # This ensures the worker's pre-check for the indexer tool passes
            if "build_index.py" in p:
                return True
            return p in {src_file, pgf_path}
    
        def fake_path_exists(self) -&gt; bool:
            # Only claim the iso_to_wiki file exists
            return str(self).replace("\\", "/").endswith("/data/config/iso_to_wiki.json")
    
        mock_proc = type(
            "Proc",
            (),
            {"returncode": 0, "stdout": "Wrote AbstractWiki.pgf", "stderr": ""},
        )()
    
        # Act
        with patch.dict(os.environ, {"AW_PGF_PATH": pgf_path}, clear=False), \
             patch("app.workers.worker.settings.FILESYSTEM_REPO_PATH", base_dir), \
             patch("app.workers.worker.os.path.exists", side_effect=fake_os_exists), \
             patch("app.workers.worker.Path.exists", fake_path_exists), \
             patch("builtins.open", mock_open(read_data=json.dumps(iso_map))), \
             patch("app.workers.worker.asyncio.to_thread", new_callable=AsyncMock, return_value=mock_proc) as mock_to_thread, \
             patch("app.workers.worker.runtime.reload", new_callable=AsyncMock) as mock_reload:
    
            # [FIX] Removed 'trace_context' arg
            result = await compile_grammar({}, lang_code)
    
        # Assert
&gt;       assert result == "Compiled deu successfully."
E       AssertionError: assert 'Source GF fi...gf/WikiDeu.gf' == 'Compiled deu successfully.'
E         
E         #x1B[0m#x1B[91m- Compiled deu successfully.#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         #x1B[92m+ Source GF file missing: /repo/gf/WikiDeu.gf#x1B[39;49;00m#x1B[90m#x1B[39;49;00m

tests/integration/test_worker_flow.py:63: AssertionError</failure></testcase><testcase classname="tests.integration.test_worker_flow.TestWorkerFlow" name="test_source_file_missing_returns_message" time="0.002"><failure message="AssertionError: assert 'Source GF fi...gf/WikiXyz.gf' == 'Source file ...gf/WikiXyz.gf'&#10;  &#10;  #x1B[0m#x1B[91m- Source file missing: /repo/gf/WikiXyz.gf#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  #x1B[92m+ Source GF file missing: /repo/gf/WikiXyz.gf#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  ?        +++#x1B[90m#x1B[39;49;00m">self = &lt;test_worker_flow.TestWorkerFlow object at 0x766ab4abec60&gt;

    async def test_source_file_missing_returns_message(self):
        base_dir = "/repo"
        pgf_path = f"{base_dir}/gf/AbstractWiki.pgf"
        src_file = f"{base_dir}/gf/WikiXyz.gf"  # 'xyz' -&gt; 'Xyz' fallback
    
        def fake_os_exists(path: str) -&gt; bool:
            # [FIX] Allow indexer to exist so we reach the grammar check
            if "build_index.py" in str(path):
                return True
            # Source file missing -&gt; early return (no subprocess call)
            return str(path) != src_file
    
        with patch.dict(os.environ, {"AW_PGF_PATH": pgf_path}, clear=False), \
             patch("app.workers.worker.settings.FILESYSTEM_REPO_PATH", base_dir), \
             patch("app.workers.worker.os.path.exists", side_effect=fake_os_exists), \
             patch("app.workers.worker.Path.exists", lambda _self: False), \
             patch("app.workers.worker.asyncio.to_thread", new_callable=AsyncMock) as mock_to_thread, \
             patch("app.workers.worker.runtime.reload", new_callable=AsyncMock) as mock_reload:
    
            # [FIX] Removed 'trace_context' arg
            result = await compile_grammar({}, "xyz")
    
&gt;       assert result == f"Source file missing: {src_file}"
E       AssertionError: assert 'Source GF fi...gf/WikiXyz.gf' == 'Source file ...gf/WikiXyz.gf'
E         
E         #x1B[0m#x1B[91m- Source file missing: /repo/gf/WikiXyz.gf#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         #x1B[92m+ Source GF file missing: /repo/gf/WikiXyz.gf#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         ?        +++#x1B[90m#x1B[39;49;00m

tests/integration/test_worker_flow.py:101: AssertionError</failure></testcase><testcase classname="tests.integration.test_worker_flow.TestWorkerFlow" name="test_compile_failure_raises_runtimeerror" time="0.002" /><testcase classname="tests.test_api_smoke" name="test_health_check_ready_exists" time="0.008" /><testcase classname="tests.test_api_smoke" name="test_health_check_live_exists" time="0.003" /><testcase classname="tests.test_api_smoke" name="test_generate_endpoint_structure_exists" time="0.004" /><testcase classname="tests.test_api_smoke" name="test_list_languages_exists" time="0.022" /><testcase classname="tests.test_api_smoke" name="test_tools_run_exists_and_is_not_default_404" time="0.025" /><testcase classname="tests.test_frames_entity" name="test_entity_family_is_present" time="0.000" /><testcase classname="tests.test_frames_entity" name="test_entity_family_members_are_canonical_and_ordered" time="0.000" /><testcase classname="tests.test_frames_entity" name="test_entity_family_members_are_unique" time="0.000" /><testcase classname="tests.test_frames_entity" name="test_entity_types_map_back_to_entity_family" time="0.000" /><testcase classname="tests.test_frames_entity" name="test_family_for_frame_works_with_entity_dicts" time="0.001" /><testcase classname="tests.test_frames_entity" name="test_entity_frame_types_have_consistent_mapping_view" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[ConflictWarEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[CulturalEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[EconomicFinancialEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[ElectionReferendumEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[ExplorationExpeditionMissionEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[HistoricalEventFrame]" time="0.001" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[LegalCaseEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[LifeEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[ScientificTechnicalMilestoneEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_are_dataclasses[SportsEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_subclass_core_event[ConflictWarEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_event_frames_subclass_core_event[LifeEventFrame]" time="0.001" /><testcase classname="tests.test_frames_event" name="test_event_frames_subclass_core_event[SportsEventFrame]" time="0.000" /><testcase classname="tests.test_frames_event" name="test_conflict_war_frame_type_constant" time="0.000" /><testcase classname="tests.test_frames_event" name="test_cultural_event_frame_type_and_main_event" time="0.000" /><testcase classname="tests.test_frames_event" name="test_economic_financial_event_frame_type_and_main_event" time="0.000" /><testcase classname="tests.test_frames_event" name="test_election_referendum_event_frame_type" time="0.000" /><testcase classname="tests.test_frames_event" name="test_exploration_expedition_mission_event_frame_type_and_default_main_event" time="0.001" /><testcase classname="tests.test_frames_event" name="test_historical_event_frame_type_and_main_event" time="0.001" /><testcase classname="tests.test_frames_event" name="test_legal_case_event_frame_type_and_main_event" time="0.000" /><testcase classname="tests.test_frames_event" name="test_life_event_frame_type_and_alias_properties" time="0.000" /><testcase classname="tests.test_frames_event" name="test_scientific_technical_milestone_event_frame_type" time="0.000" /><testcase classname="tests.test_frames_event" name="test_sports_event_frame_type_and_subclassing" time="0.000" /><testcase classname="tests.test_frames_meta" name="test_meta_family_is_present" time="0.000" /><testcase classname="tests.test_frames_meta" name="test_meta_family_members_are_canonical_and_ordered" time="0.001" /><testcase classname="tests.test_frames_meta" name="test_meta_family_members_are_unique" time="0.001" /><testcase classname="tests.test_frames_meta" name="test_meta_types_map_back_to_meta_family" time="0.000" /><testcase classname="tests.test_frames_meta" name="test_family_for_frame_works_with_meta_dicts" time="0.001" /><testcase classname="tests.test_frames_meta" name="test_infer_frame_type_prefers_explicit_frame_type_key" time="0.000" /><testcase classname="tests.test_frames_narrative" name="test_timeline_chronology_basic_construction" time="0.001" /><testcase classname="tests.test_frames_narrative" name="test_career_season_campaign_summary_basic" time="0.000" /><testcase classname="tests.test_frames_narrative" name="test_development_evolution_basic" time="0.001" /><testcase classname="tests.test_frames_narrative" name="test_reception_impact_basic" time="0.000" /><testcase classname="tests.test_frames_narrative" name="test_structure_organization_basic" time="0.000" /><testcase classname="tests.test_frames_narrative" name="test_comparison_set_contrast_basic" time="0.000" /><testcase classname="tests.test_frames_narrative" name="test_list_enumeration_basic" time="0.000" /><testcase classname="tests.test_frames_narrative" name="test_default_containers_are_empty_and_independent" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_attribute_frame_basic_construction" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_attribute_frame_frame_type_constant" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_definition_classification_frame_basic" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_membership_frame_basic_construction" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_ownership_control_frame_basic_construction" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_ownership_control_frame_with_share" time="0.001" /><testcase classname="tests.test_frames_relational" name="test_part_whole_composition_basic" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_role_position_office_basic" time="0.002" /><testcase classname="tests.test_frames_relational" name="test_spatial_relation_frame_defaults_and_update" time="0.000" /><testcase classname="tests.test_frames_relational" name="test_temporal_relation_frame_basic" time="0.001" /><testcase classname="tests.test_gf_dynamic" name="test_grammar_has_supported_languages" time="0.028" /><testcase classname="tests.test_gf_dynamic" name="test_linearize_simple_phrase" time="0.001" /><testcase classname="tests.test_lexicon_index" name="test_profession_lookup_by_lemma_and_key" time="0.001" /><testcase classname="tests.test_lexicon_index" name="test_nationality_lookup" time="0.001" /><testcase classname="tests.test_lexicon_index" name="test_lookup_any_falls_back_to_general_entries" time="0.001" /><testcase classname="tests.test_lexicon_index" name="test_missing_lemma_returns_none_instead_of_crashing" time="0.001" /><testcase classname="tests.test_lexicon_loader" name="test_load_lexicon_fr_basic" time="0.008"><failure message="AssertionError: assert 'physicien' in {}&#10; +  where {} = Lexicon(meta=LexiconMeta(language='fr', family=None, version=None, description=None, extra={'schema_version': 2}), pro...mality=None, wikidata_qid=None, forms={}, extra={'key': 'polonais'})}, name_templates={}, raw={'files': ['core.json']}).professions">temp_lexicon_dir = PosixPath('/tmp/pytest-of-kingk/pytest-8/test_load_lexicon_fr_basic0')

    def test_load_lexicon_fr_basic(temp_lexicon_dir) -&gt; None:
        """French lexicon should load and contain key biography lemmas."""
        # Configure loader to use the temp dir
        cfg = LexiconConfig(lexicon_dir=str(temp_lexicon_dir))
        set_config(cfg)
    
        lex = load_lexicon("fr")
        assert isinstance(lex, Lexicon)
    
        # Check professions map (Lemma)
&gt;       assert "physicien" in lex.professions
E       AssertionError: assert 'physicien' in {}
E        +  where {} = Lexicon(meta=LexiconMeta(language='fr', family=None, version=None, description=None, extra={'schema_version': 2}), pro...mality=None, wikidata_qid=None, forms={}, extra={'key': 'polonais'})}, name_templates={}, raw={'files': ['core.json']}).professions

tests/test_lexicon_loader.py:103: AssertionError</failure></testcase><testcase classname="tests.test_lexicon_loader" name="test_load_lexicon_pt_basic" time="0.003" /><testcase classname="tests.test_lexicon_loader" name="test_load_lexicon_ru_basic" time="0.003" /><testcase classname="tests.test_lexicon_loader" name="test_load_lexicon_unknown_language_raises" time="0.002" /><testcase classname="tests.test_lexicon_smoke" name="test_lexicon_directory_exists" time="0.003" /><testcase classname="tests.test_lexicon_smoke" name="test_at_least_one_language_detected" time="0.002" /><testcase classname="tests.test_lexicon_smoke" name="test_language_directories_integrity" time="0.009" /><testcase classname="tests.test_lexicon_smoke" name="test_lexicon_schema_has_no_errors" time="0.002" /><testcase classname="tests.test_lexicon_wikidata_bridge" name="test_build_lexicon_from_line_delimited_json" time="0.002"><failure message="AssertionError: assert 'wikidata_dump' == 'wikidata_lexeme_dump'&#10;  &#10;  #x1B[0m#x1B[91m- wikidata_lexeme_dump#x1B[39;49;00m#x1B[90m#x1B[39;49;00m&#10;  ?          -------#x1B[90m#x1B[39;49;00m&#10;  #x1B[92m+ wikidata_dump#x1B[39;49;00m#x1B[90m#x1B[39;49;00m">tmp_path = PosixPath('/tmp/pytest-of-kingk/pytest-8/test_build_lexicon_from_line_d0')

    def test_build_lexicon_from_line_delimited_json(tmp_path) -&gt; None:
        """
        Ensure that a simple line-delimited JSON dump with a single Lexeme
        yields a lexicon with the expected lemma, POS, QID, and meta.
        """
        dump_path = tmp_path / "lexemes_ldjson.json"
    
        lexeme = _make_sample_lexeme(
            lexeme_id="L1",
            lang="it",
            lemma_value="fisico",
            lexical_category_qid="Q24905",  # noun
            sense_qid="Q169470",
        )
    
        # Write one lexeme per line
        with dump_path.open("w", encoding="utf-8") as f:
            f.write(json.dumps(lexeme, ensure_ascii=False) + "\n")
    
        lexicon = build_lexicon_from_dump("it", str(dump_path))
    
        # Basic meta
        meta = lexicon.get("meta", {})
        assert meta.get("language") == "it"
&gt;       assert meta.get("source") == "wikidata_lexeme_dump"
E       AssertionError: assert 'wikidata_dump' == 'wikidata_lexeme_dump'
E         
E         #x1B[0m#x1B[91m- wikidata_lexeme_dump#x1B[39;49;00m#x1B[90m#x1B[39;49;00m
E         ?          -------#x1B[90m#x1B[39;49;00m
E         #x1B[92m+ wikidata_dump#x1B[39;49;00m#x1B[90m#x1B[39;49;00m

tests/test_lexicon_wikidata_bridge.py:87: AssertionError</failure></testcase><testcase classname="tests.test_lexicon_wikidata_bridge" name="test_build_lexicon_from_gzipped_dump" time="0.002"><failure message="AssertionError: assert None == 'lexemes_dump.json.gz'&#10; +  where None = &lt;built-in method get of dict object at 0x766aaf6292c0&gt;('source_dump')&#10; +    where &lt;built-in method get of dict object at 0x766aaf6292c0&gt; = {'language': 'it', 'schema_version': 2, 'source': 'wikidata_dump'}.get&#10; +  and   'lexemes_dump.json.gz' = PosixPath('/tmp/pytest-of-kingk/pytest-8/test_build_lexicon_from_gzippe0/lexemes_dump.json.gz').name">tmp_path = PosixPath('/tmp/pytest-of-kingk/pytest-8/test_build_lexicon_from_gzippe0')

    def test_build_lexicon_from_gzipped_dump(tmp_path) -&gt; None:
        """
        Ensure that gzipped dumps are handled correctly and produce the
        same lexicon structure as plain JSON.
        """
        dump_path = tmp_path / "lexemes_dump.json.gz"
    
        lexeme = _make_sample_lexeme(
            lexeme_id="L2",
            lang="it",
            lemma_value="chimico",
            lexical_category_qid="Q24905",  # noun
            sense_qid="Q593644",
        )
    
        # Write gzipped line-delimited JSON
        with gzip.open(dump_path, "wt", encoding="utf-8") as f:
            f.write(json.dumps(lexeme, ensure_ascii=False) + "\n")
    
        lexicon = build_lexicon_from_dump("it", str(dump_path))
    
        meta = lexicon.get("meta", {})
        assert meta.get("language") == "it"
&gt;       assert meta.get("source_dump") == dump_path.name
E       AssertionError: assert None == 'lexemes_dump.json.gz'
E        +  where None = &lt;built-in method get of dict object at 0x766aaf6292c0&gt;('source_dump')
E        +    where &lt;built-in method get of dict object at 0x766aaf6292c0&gt; = {'language': 'it', 'schema_version': 2, 'source': 'wikidata_dump'}.get
E        +  and   'lexemes_dump.json.gz' = PosixPath('/tmp/pytest-of-kingk/pytest-8/test_build_lexicon_from_gzippe0/lexemes_dump.json.gz').name

tests/test_lexicon_wikidata_bridge.py:125: AssertionError</failure></testcase><testcase classname="tests.test_lexicon_wikidata_bridge" name="test_duplicate_lemmas_keep_first" time="0.003"><failure message="KeyError: 'features'">tmp_path = PosixPath('/tmp/pytest-of-kingk/pytest-8/test_duplicate_lemmas_keep_fir0')

    def test_duplicate_lemmas_keep_first(tmp_path) -&gt; None:
        """
        If multiple Lexeme objects produce the same lemma in the target
        language, the builder should keep the first and ignore later ones.
        """
        dump_path = tmp_path / "lexemes_dups.json"
    
        lexeme1 = _make_sample_lexeme(
            lexeme_id="L10",
            lang="it",
            lemma_value="autore",
            lexical_category_qid="Q24905",
            sense_qid="Q1",
        )
        lexeme2 = _make_sample_lexeme(
            lexeme_id="L11",
            lang="it",
            lemma_value="autore",
            lexical_category_qid="Q24905",
            sense_qid="Q2",
        )
    
        with dump_path.open("w", encoding="utf-8") as f:
            f.write(json.dumps(lexeme1, ensure_ascii=False) + "\n")
            f.write(json.dumps(lexeme2, ensure_ascii=False) + "\n")
    
        lexicon = build_lexicon_from_dump("it", str(dump_path))
    
        lemmas = lexicon.get("lemmas", {})
        assert "autore" in lemmas
        entry = lemmas["autore"]
    
        # First lexeme should win
&gt;       assert entry["features"]["lexeme_id"] == "L10"
               ^^^^^^^^^^^^^^^^^
E       KeyError: 'features'

tests/test_lexicon_wikidata_bridge.py:171: KeyError</failure></testcase><testcase classname="tests.test_multilingual_generation" name="test_engine_languages" time="0.072" /><testcase classname="tests.test_multilingual_generation" name="test_literal_generation" time="0.000" /><testcase classname="tests.test_multilingual_generation" name="test_transitive_event" time="0.000" /><testcase classname="tests.test_multilingual_generation" name="test_error_handling_invalid_ninai" time="0.002" /></testsuite></testsuites>