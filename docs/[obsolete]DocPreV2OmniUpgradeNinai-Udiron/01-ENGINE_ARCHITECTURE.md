
# ðŸ›ï¸ Engine Architecture & Internals

**Abstract Wiki Architect**

## 1. High-Level System Overview

The Abstract Wiki Architect is a **Rule-Based Natural Language Generation (NLG) Engine**. Unlike statistical models (LLMs) that predict the next token based on probability, this system constructs sentences deterministically using linguistic rules (Grammar) and structured data (Lexicon).

It is designed to solve the **"Long Tail" Problem**: ensuring verifiable, high-quality encyclopedic text generation for 300+ languages, from high-resource languages like English (Tier 1) to under-resourced languages like Zulu or Quechua (Tier 3).

### The Core Philosophy: Separation of Concerns

The architecture separates the system into three distinct layers to ensure modularity and scalability:

1. **Layer A: The Lexicon (Data)**
* **Role:** The vocabulary. Stores words and their inherent properties (gender, stems).
* **Strategy:** **Usage-Based Sharding**. Data is organized by domain (`core`, `people`, `science`) rather than monolithic dictionary files.
* **Source:** Wikidata (upstream)  JSON Shards (downstream optimization).


2. **Layer B: The Grammar Matrix (Logic)**
* **Role:** The rules. Defines morphology (inflection) and syntax (word order).
* **Mechanism:** Uses the **Grammatical Framework (GF)** to define abstract syntax trees that are linearized into concrete strings.
* **Hybrid Approach:** It combines expert-written grammars (RGL) with auto-generated "Pidgin" grammars (Factory) to guarantee 100% coverage.


3. **Layer C: The Renderer (Presentation)**
* **Role:** The assembly. Takes an abstract intent (Semantic Frame) and combines it with the Lexicon and Grammar to produce text.
* **Input:** Semantic Frames (e.g., `BioFrame`, `EventFrame`).
* **Output:** Natural Language Text.



---

## 2. The Hybrid Factory Architecture

To scale from ~40 academic languages to the 300+ required by Wikipedia, we employ a **Three-Tiered Hybrid System**:

### Tier 1: The "High Road" (RGL)

* **Source:** The official **GF Resource Grammar Library**.
* **Quality:** Expert-written, linguistically perfect. Handles complex morphology (case declension, verb conjugation).
* **Examples:** English (`eng`), French (`fra`), Russian (`rus`), Hindi (`hin`).
* **Build Strategy:** `HIGH_ROAD`.

### Tier 2: Manual Contrib (Overrides)

* **Source:** `gf/contrib/{lang}/`.
* **Quality:** Community-contributed grammars that are not yet in the official RGL but are better than machine-generated stubs.
* **Role:** Overrides both Tier 1 and Tier 3 if present.

### Tier 3: The "Factory" (Generated)

* **Source:** `generated/src/{lang}/`.
* **Quality:** "Pidgin" or simplified grammars generated by `utils/grammar_factory.py`. They ensure the API never returns a 404, even if the output is grammatically simple (e.g., SVO string concatenation).
* **Examples:** Zulu (`zul`), Quechua (`que`), Yoruba (`yor`).
* **Build Strategy:** `SAFE_MODE`.

---

## 3. The "Two-Phase" Build Pipeline

We identified a critical issue in the standard GF build process where sequential compilation overwrites the binary (the "Last Man Standing" bug). The new **Build Orchestrator** (`gf/build_orchestrator.py`) implements a strict two-phase process to resolve this.

### Phase 1: Isolated Verification

The orchestrator iterates through the **Everything Matrix** inventory:

1. **Resolve Path:** Determines if the language is Tier 1 (RGL), Tier 2 (Contrib), or Tier 3 (Factory).
2. **Compile:** Runs `gf -batch -c path/to/Wiki{Lang}.gf`.
3. **Output:** Generates a temporary `.gfo` (object file).
4. **Verdict:** If compilation fails, the language is dropped from the build, but the pipeline *continues*.

### Phase 2: Global Linking

Once all languages are verified:

1. **Aggregate:** The orchestrator collects the file paths of all successful Phase 1 candidates.
2. **Link:** It executes a **single** `gf -make` command containing the Abstract Grammar and *all* valid Concrete Grammars.
3. **Result:** A single `AbstractWiki.pgf` binary containing 50+ languages.

---

## 4. The "Everything Matrix" (The Brain)

The system is no longer driven by static config files. It uses a **Dynamic Registry** called the **Everything Matrix** (`data/indices/everything_matrix.json`).

### The Scanning Suite (`tools/everything_matrix/`)

Before any build, the system runs a deep-tissue audit:

* **`rgl_auditor.py`**: Scans `gf-rgl/src` to detect which modules (`Cat`, `Noun`, `Paradigms`) exist on disk. It assigns a **Maturity Score (0-10)**.


* 
**`lexicon_scanner.py`**: Audits `data/lexicon/` to count vocabulary size and ensure "Seed" files (`core.json`) are present.


* **`build_index.py`**: The master script. It runs the sub-scanners and updates the JSON matrix.

### Decision Logic

The Build Orchestrator reads the Matrix to decide how to treat a language:

* **Score > 7:** Build as **Tier 1** (High Road).
* **Score < 7:** Downgrade to **Tier 3** (Safe Mode / Factory) to prevent build failures.

---

## 5. Hexagonal Architecture (The Code)

The backend follows **Ports and Adapters** (Hexagonal) architecture to keep the core domain logic isolated from external tools (Docker, Redis, Filesystem).

### The Core (`app/core/`)

* **Domain:** Pure Python classes (`BioFrame`, `Language`, `Sentence`). No external dependencies.
* **Ports:** Interfaces defining *what* the system needs (e.g., `IGrammarEngine`, `IMessageBroker`).

### The Adapters (`app/adapters/`)

* **API:** FastAPI implementation handling HTTP requests.
* **Persistence:** File-system adapters reading the `gf/` directory.
* **Messaging:** Redis adapter for async task queues.

### The Application (`app/shared/`)

* **Config:** `config.py` is the single source of truth for paths and environment variables.
* **Container:** Dependency Injection wiring.

---

## 6. Directory Map & Key Files

| Path | Component | Description |
| --- | --- | --- |
| **`gf/build_orchestrator.py`** | <br>**The Builder** |  The script that runs the Two-Phase compilation.

 |
| **`tools/everything_matrix/`** | <br>**The Auditor** |  Contains `build_index.py`, `rgl_auditor.py`.

 |
| **`data/indices/everything_matrix.json`** | <br>**The Registry** |  The dynamic state of the system (regenerated daily).

 |
| **`gf-rgl/`** | <br>**Tier 1 Source** |  External submodule containing expert grammars.

 |
| **`generated/src/`** | <br>**Tier 3 Source** |  Folder for auto-generated "Factory" grammars.

 |
| **`gf/AbstractWiki.pgf`** | ** The Artifact**

 |  The final compiled binary used by the API.

 |
| **`app/workers/worker.py`** | <br>**The Worker** |  Async process that Hot-Reloads the PGF binary.

 |

---

## 7. Data Flow: The Request Lifecycle

1. **Request:** User POSTs a `BioFrame` to `/api/v1/generate`.
2. **Validation:** API validates the JSON against the Pydantic schema.
3. **Dispatch:** The backend queries the loaded `AbstractWiki.pgf` via the C-runtime (`pgf`).
4. **Concrete Linearization:**
* The engine selects the specific concrete grammar (e.g., `WikiFra`).
* It looks up vocabulary in the **Lexicon**.
* It applies morphological rules (from **RGL** or **Factory**).


5. **Response:** The generated string is returned with metadata (latency, engine used).

---

## 8. Hot-Reloading Mechanism

To ensure high availability, the system supports **Zero-Downtime Updates**.

1. **Build:** `build_orchestrator.py` creates a new `AbstractWiki.pgf`.
2. **Watch:** The `app/workers/worker.py` has a background task watching the file modification time (`mtime`) of the binary.
3. **Reload:** When a change is detected, the worker re-initializes the C-runtime memory pointer to the new file *without* restarting the Docker container.
4. **Sync:** The Backend API and Worker share the same physical volume (`/app/gf`), ensuring they always see the same version of the grammar.